# -*- coding: utf-8 -*-
"""
Callbacks dealing with the upload tab
"""
import base64
import csv
import io
import json

import requests
from dash import ALL, MATCH, Input, Output, State, ctx, dcc, html
from dash.exceptions import PreventUpdate

from api.centree import CENtree_object
from app import app
from backend import get_metadata_fields, upload_files_data_metadata
from databases import Metadata
from store_functions import Store, extract_values_from_context


@app.callback(
    Output('metadata_fields', 'data'),
    Input('upload-store-selector', 'value'))
def load_metadata_fields(metadata_store):
    """
    Gets the metadata fields.
    TODO: this should also trigger the rebuilding the metadata div?
    """
    fields = get_metadata_fields(metadata_store)
    return fields


@app.callback(
    Output('required-metadata-div', 'children'),
    Output('further-metadata-selector', 'children'),
    Input('upload-data', 'filename'),
    Input('metadata_fields', 'data'),
    State('upload-store-selector', 'value'),
    prevent_initial_call=True)
def build_forms(filename, fields, metadata_store):
    """
    Prepares a div with forms, guiding the addition of
    metadata before the file is uploaded
    """
    if not filename:
        raise PreventUpdate
    metadata_fields = [Metadata.from_record(**f) for f in fields]
    autogenerated_metadata = [
        item for item in metadata_fields if item.autogenerated]
    auto_list = [i.label for i in autogenerated_metadata]
    auto_info = f"""
    The system will autogenerate metadata for these fields:
    {', '.join(auto_list)},
    and will autocomplete from centree for these fields:
    {', '.join([i.label for i in metadata_fields if i.lookup])}.
    """
    required_metadata = [
        item for item in metadata_fields if item.required and not item.autogenerated
    ]
    required_div = []
    if len(autogenerated_metadata) > 0:
        required_div.append(
            html.Div(auto_info)
        )
    required_info = f"""
    Before we continue to upload file {filename}, some information is required:
    please fill in the forms below.
    """

    if len(required_metadata) > 0:
        required_div.append(
            html.Div(required_info)
        )
        for item in required_metadata:
            required_div.append(item.upload_div(
                label='required',
                placeholder=f'Select a {item.label} value'
            ))
    else:
        required_div =  ['No required metadata tag to be added.']
    optional_list = [
        item.label for item in metadata_fields if not item.required and not item.autogenerated
    ]
    if len(optional_list) > 0:
        optional_info = "Select all the metadata you'd like to add from the selector below"
        optional_div_selector = [
            html.Div(optional_info),
            dcc.Dropdown(
                optional_list,
                placeholder='Select a metadata key',
                multi=True,
                id='more-metadata-dropdown',
            ),
        ]
    else:
        # to avoid complaints of non-existing input in callback
        # I need to add an invisible div with an empty dropdown
        optional_div_selector = [
            html.Div('No optional metadata tag to be added.'),
            dcc.Dropdown(
                optional_list,
                id='more-metadata-dropdown',
                style={'display': 'none'}
            )
        ]
    return required_div, optional_div_selector


@app.callback(
    Output('further-metadata', 'children'),
    Input('further-metadata-selector', 'children'),
    Input('more-metadata-dropdown', 'value'),
    Input({'type': 'optional-metadata-selector', 'index': ALL}, 'value'),
    State('upload-store-selector', 'value'),
    State('metadata_fields', 'data'),
    prevent_initial_call=True)
def further_metadata_input(_, values, optional_values, store, fields):
    div = []
    if not values:
        return div
    metadata_fields = [Metadata.from_record(**f) for f in fields]
    # select the metadata corresponding to the selected dropdown
    keys, vals = extract_values_from_context(ctx.inputs_list[2])
    for value in values:
        for field in metadata_fields:
            if field.label == value:
                item = field
            old_value = vals[keys.index(value)] if value in keys else None
        div.append(
            item.upload_div(
                label='optional',
                value=old_value,
                placeholder=f'Select a {item.label} value')
        )
    return div


@app.callback(
    Output('confirm-upload', 'displayed'),
    Input('final-upload', 'n_clicks'))
def display_confirm(value):
    if value > 0:
        return True
    return False


def update_options(search_value, root, fields):
    """
    Reusable function to dynamically generate the option of a dropdown based
    on the value of the search value, from a centree lookup call
    """
    if not search_value:
        raise PreventUpdate
    metadata_fields = [Metadata.from_record(**f) for f in fields]
    triggers = [i['index'] for i in ctx.triggered_prop_ids.values()]
    for x in metadata_fields:
        if x.label in triggers:
            r = root if root else x.centree.attributes.shortFormIDs[0]
            s = x.centree.form_search(r, search_value)
            return [
                {'label': i['primaryLabel'],
                 'value': i['id']} for i in s]


@app.callback(
    Output({'type': 'required-lookup', 'index': MATCH}, 'options'),
    Input({'type': 'required-lookup', 'index': MATCH}, 'search_value'),
    State({'type': 'required-filter', 'index': MATCH}, 'value'),
    State('metadata_fields', 'data'),
    prevent_initial_call=True)
def update_required(*args, **kwargs):
    return update_options(*args, **kwargs)


@app.callback(
    Output({'type': 'optional-lookup', 'index': MATCH}, 'options'),
    Input({'type': 'optional-lookup', 'index': MATCH}, 'search_value'),
    State({'type': 'optional-filter', 'index': MATCH}, 'value'),
    State('metadata_fields', 'data'),
    prevent_initial_call=True)
def update_optional(*args, **kwargs):
    return update_options(*args, **kwargs)


def update_filters(value, fields):
    if not value:
        raise PreventUpdate
    triggers = [i['index'] for i in ctx.triggered_prop_ids.values()]
    metadata_fields = [Metadata.from_record(**f) for f in fields]
    for x in metadata_fields:
        if x.label in triggers:
            s = x.centree.path_from_root(value)
            val = {}
            while s and val.get('id', '') != x.centree.attributes.id:
                val = s.pop(0)
            if s[-1]['id'] == value:
                final = '✅'
            else:
                val = s.pop()
                final = '...'
            allvals = [i['primaryLabel'] for i in s] + [final]
            return [
                {
                    'label': '⇾'.join(allvals),
                    'value': s[-1]['shortFormIDs'][0]
                },
                {
                    'label': x.label,
                    'value': x.centree.attributes.shortFormIDs[0]
                }]


@app.callback(
    Output({'type': 'required-filter', 'index': MATCH}, 'options'),
    Input({'type': 'required-lookup', 'index': MATCH}, 'value'),
    State('metadata_fields', 'data'),
    prevent_initial_call=True)
def update_required_filters(*args, **kwargs):
    return update_filters(*args, **kwargs)


@app.callback(
    Output({'type': 'optional-filter', 'index': MATCH}, 'options'),
    Input({'type': 'optional-lookup', 'index': MATCH}, 'value'),
    State('metadata_fields', 'data'),
    prevent_initial_call=True)
def update_optional_filters(*args, **kwargs):
    return update_filters(*args, **kwargs)


@app.callback(
    Output({'type': 'required-filter', 'index': MATCH}, 'value'),
    Input({'type': 'required-filter', 'index': MATCH}, 'options'),
    prevent_initial_call=True)
def update_req_filter_values(options):
    return options[0]['value']


@app.callback(
    Output({'type': 'optional-filter', 'index': MATCH}, 'value'),
    Input({'type': 'optional-filter', 'index': MATCH}, 'options'),
    prevent_initial_call=True)
def update_opt_filter_values(options):
    return options[0]['value']


@app.callback(
    Output('final-upload', 'disabled'),
    Input({'type': 'required', 'index': ALL}, 'value'),
    Input({'type': 'required-lookup', 'index': ALL}, 'value'),
    Input({'type': 'required-date', 'index': ALL}, 'date'),
    prevent_initial_call=True)
def enable_upload_button(form_values, lookup_values, date_values):
    allforms = form_values + lookup_values + date_values
    if all(v is not None and str(v) != '' for v in allforms):
        return False
    return True


inputs = dict(
    btn1=Input(
        'btn-1',
        'n_clicks'),
    btn2=Input(
        'btn-2',
        'n_clicks')
)


@app.callback(
    Output('uploaded-metadata', 'children'),
    inputs=dict(
        btn=Input('final-upload', 'n_clicks'),
        file_name=State('upload-data', 'filename'),
        fields=State('metadata_fields', 'data'),
        file_content=State('upload-data', 'contents'),
        store=State('upload-store-selector', 'value'),
        required=State({'type': 'required', 'index': ALL}, 'value'),
        required_lookup=State({'type': 'required-lookup', 'index': ALL}, 'value'),
        required_date=State({'type': 'required-date', 'index': ALL}, 'date'),
        optional=State({'type': 'optional', 'index': ALL}, 'value'),
        optional_lookup=State({'type': 'optional-lookup', 'index': ALL}, 'value'),
        optional_date=State({'type': 'optional-date', 'index': ALL}, 'date')
    ),
    prevent_initial_call=True)
def print_uploaded_metadata(
    btn, file_name, file_content, store, fields,
    required, required_lookup, required_date,
    optional, optional_lookup, optional_date):
    """
    Finally collects all the key:value pairs, and upload files to the
    relevant store. Metadata file is generated, converted to csv and updated.
    As of requests from AWS store. Probably json will be better
    """
    if btn < 1:
        return []
    div = [html.Br()]
    keys = []
    vals = []
    args = ctx.args_grouping
    for arg in [
        'required', 'required_lookup', 'required_date',
        'optional', 'optional_lookup', 'optional_date']:
        key, val = extract_values_from_context(args[arg])
        keys += key
        vals += val
    output = {}
    for key, val in zip(keys, vals):
        #if v is not None:
        #    output[k] = v
        output[key] = val

    # HACKING FILE NAMES FOR LAMBDA COHERENCE
    # JUST CHANGE WHAT IS NECESSSARY

    if file_name.endswith('.csv'):
        f_upload = file_name
        f_meta = f'{file_name[:-4]}-metadata.csv'
    else:
        f_upload = f'{file_name}.csv'
        f_meta = f'{file_name}-metadata.csv'

    # HACKING END

    # This is parsing the base64 encoding of the upload object in fastapi
    decoded = base64.b64decode(file_content.split(',')[1])
    content = io.BytesIO(decoded)

    # ORDER MATTERS! This is for GLUE store on AWS, where crawling depends on csv key order
    # horrible hacks for lowercase/uppercase
    # what's to change is the lambda on aws! too fragile

    camelcase_from_lowercase = {k.lower(): k for k in output.keys()}
    lowercase_schema = [k.lower() for k in Store(store).get_schema()]
    upload_fields = {f['field_name'].lower(): Metadata.from_record(**f)
                     for f in fields if not f['autogenerated']}

    output_keys = [camelcase_from_lowercase[k]
                   for k in lowercase_schema if upload_fields.get(k, None)]
    output_values = [output.get(key) for key in output_keys]

    writer = io.StringIO()
    csvfile = csv.writer(writer)
    csvfile.writerow(list(output_keys))
    csvfile.writerow(list(output_values))

    files = [
        ('files', (f_upload, content)),
        ('files', (f_meta, writer.getvalue())),
    ]

    response = upload_files_data_metadata(files, store)

    print(response)

    if len(output) == 0:
        return [div + [html.Div('No metadata')]]
    return div + [dcc.Markdown(f'''
metadata:
```javascript

{json.dumps(output, indent=4)}

```
''')]
