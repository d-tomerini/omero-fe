# -*- coding: utf-8 -*-
"""
Initial data sources to be substituted with database and API calls
"""
from datetime import date

import dash_bootstrap_components as dbc
import requests
import urllib3
from dash import dcc, html

from api.centree import CENtree_object

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class Metadata:
    """
    A class dealing with metadata information required to be uploaded
    The GUI should pick it up and fill it in according to its description
    list according to the ongoing stub:
     `https://cslpromise-my.sharepoint.com/:x:/g/personal/
     matthew_wiener_cslbehring_com/EW-fKeHfnYxNvY7acD3z8YYBkJM_AoqygDcRydRxcwEiVg`
    """

    def __init__(
            self,
            label: str,
            centree=None,
            centree_depth: int = 0,
            required: bool = False,
            autogenerated: bool = False,
            searchable: str = 'freetext',
            search_list: list = [],
            content_type: str = 'text'):
        """
        Initialises a list of requirements for the metadata fields
        :param label: primary identifier
        :param centree: ontology related to the definition, and leaves can populate entries
        :param centree_depth: when building search, how deep I should look
        :param required: for upload, that is a not `None`
        :param autogenerated: the system might build this unique field (e.g. UUID identifier)
        :param searchable: whether it takes values from a source.
            Currently 'centree', 'lookup'. 'hardcoded.
        :param search_list: the hardcoded list for filling possible values
        :content_type: type of value, to build a better experience (text, number, datetime, array(?))
        """
        self.label = label
        self.centree = centree
        self.centree_depth = centree_depth
        self.required = required
        self.autogenerated = autogenerated
        self.searchable = searchable
        self.search_list = search_list
        self.content_type = content_type
        self.lookup = (self.searchable == 'lookup')

    @classmethod
    def from_record(
            cls,
            field_name,
            required,
            autogenerated,
            searchable,
            search_list,
            content_type,
            centree_name,
            centree_ontology):
        """
        Constructor from database record.
        As it it stored in database from pydantic model
        with defaults, every fields shouls be as expected.
        Modify as needed
        """

        if centree_name:
            centree = CENtree_object(
                primaryLabel=centree_name,
                ontology=centree_ontology
            )
        else:
            centree = None
        return cls(
            label=field_name,
            centree=centree,
            centree_depth=0,
            required=required,
            autogenerated=autogenerated,
            searchable=searchable,
            search_list=search_list,
            content_type=content_type)

    def get_search_list(self, depth=0):
        """
        Infer the right array to be used in search
        Depth: TODO. How deep to go in the ontology to show possibilities
        """
        if self.searchable == 'hardcoded':
            return self.search_list
        if self.searchable == 'centree':
            children = self.centree.subclass_search()
            return [item.primaryLabel for item in children]
        return []

    def upload_div(self, label, placeholder, value=None):
        """
        returns a dash div based on the actual content of the Metadata field
        according to the self.type, it can return either an Input, a Dropdown or a DatePicker
        """

        if self.content_type == 'Datetime':
            element_id = {'type': f'{label}-date', 'index': self.label}
            return dbc.InputGroup([
                dbc.InputGroupText(self.label),
                dcc.DatePickerSingle(
                    id=element_id,
                    date=date.today(),
                    clearable=True,
                    display_format='MMM Do, YYYY',
                    calendar_orientation='vertical',
                    placeholder=placeholder,
                    className='dash-bootstrap',
                   #style={"min-width": "400px"}
                )
            ],
            )
        element_id = {'type': label, 'index': self.label}
        # input is freetext and not Datetime
        if self.searchable == 'freetext':
            return dbc.InputGroup([
                dbc.InputGroupText(self.label),
                dbc.Input(
                    id=element_id,
                    type=self.content_type,
                    persistence=False,
                    autocomplete='off',
                    autofocus=True,
                    placeholder=placeholder,
                ),
            ])
        # if it is searchable, it is a dropdown
        # hardcoded with given depth
        options = self.get_search_list(self.centree_depth)
        if self.lookup:
            element_id = {'type': f'{label}-lookup', 'index': self.label}
            filter_label = f'{label}-filter'
            filter_id = {'type': filter_label, 'index': self.label}
            return dbc.InputGroup([
                dbc.InputGroupText(self.label),
                dcc.Dropdown(
                    options=[{'label': v, 'value': v} for v in options],
                    value=value,
                    placeholder='Select...',
                    id=element_id,
                    style={'width': 'auto', 'min-width': '250px'},
                    className='dash-bootstrap'
                ),
                dbc.InputGroupText('@'),
                dcc.Dropdown(
                    options=[
                        {'label': self.label,
                         'value': self.centree.attributes.shortFormIDs[0]}
                    ],
                    value=self.centree.attributes.shortFormIDs[0],
                    multi=False,
                    clearable=False,
                    searchable=False,
                    disabled=False,
                    id=filter_id,
                    style={'width': 'auto', 'min-width': '450px'},
                    className='dash-bootstrap'
                )
            ],
            )
        return dbc.InputGroup([
            dbc.InputGroupText(self.label),
            dcc.Dropdown(
                options=options,
                value=value,
                placeholder='Select...',
                id=element_id,
                style={'width': 'auto', 'min-width': '200px'},
                className='dash-bootstrap'
            )
        ])

    def get_datalist(self, label=None):
        """OBSOLETE Returns a datalist for autocomplete"""
        return html.Datalist(
            id=f'{self.label}-{label}-list',
            children=[])
